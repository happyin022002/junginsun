<?xml version="1.0" encoding="UTF-8"?>
<sqls>
	<querys>
		<query name="ProductCatalogCreateDBDAOGetReplanePatternRSQL">
			<desc><![CDATA[GetReplanePattern
20130227 , cntr type Q type(void) 은 순위가 뒤로 가도록 수정]]></desc>
			<sql><![CDATA[
WITH FH_QTY AS (
select 
    BKG_NO,CNTR_TPSZ_CD,CNTR_NO,COP_NO,OB_TRO_FLG,IB_TRO_FLG,OB_FSH_FLG,IB_FSH_FLG,CALC_COP_OP_TP_CD,USED,SO_KNT,OP_CNTR_QTY,BKG_CNTR_TPSZ_CD,SCE_CNTR_TPSZ_CD,BKG_PROV_CNTR_TPSZ_CD,SCE_PROV_CNTR_TPSZ_CD
    ,case when used in('0','1','2','3','4','5','6','8','9') then 'Y'
          when USED = '7' and row_number() over (partition by BKG_CNTR_TPSZ_CD,OP_CNTR_QTY   order by COP_NO ) <= CEIL(OP_CNTR_QTY)  then 'Y'
          else  'N'
     end used2        
from (
SELECT -- HJCU0000000 중 tpsz가 다르지만 호환 가능한 것끼리 연결된다. (priority 4)
      BKG_NO
     , DECODE(SUBSTR(N4TH_MAP, 1,2)
              --, 'WK' , NVL(MAX(BKG_CNTR_TPSZ_CD), MAX(SCE_CNTR_TPSZ_CD)) -- BKG TPSZ을 우선 따라가도록 처리
			  , 'WK' , DECODE(NVL(MAX(DECODE(CNTR_NO, 'SMCU0000000', NULL, CNTR_NO)), 'SMCU0000000') , 'SMCU0000000',NVL(MAX(BKG_CNTR_TPSZ_CD), MAX(SCE_CNTR_TPSZ_CD) ) , NVL(MAX(SCE_CNTR_TPSZ_CD), MAX(BKG_CNTR_TPSZ_CD) )  )
              , NVL(MAX(SCE_CNTR_TPSZ_CD), MAX(BKG_CNTR_TPSZ_CD))) CNTR_TPSZ_CD
     , NVL(MAX(DECODE(CNTR_NO, 'SMCU0000000', NULL, CNTR_NO)), 'SMCU0000000') CNTR_NO
     , MAX(COP_NO) COP_NO
     , MAX(OB_TRO_FLG) OB_TRO_FLG
     , MAX(IB_TRO_FLG) IB_TRO_FLG
     , DECODE(MAX(COP_DTL_SEQ), NULL, 'N', 'Y') OB_FSH_FLG
     , DECODE(MAX(COP_DTL_SEQ), NULL, 'N', DECODE(MAX(COP_STS_CD), 'F', 'Y', 'N')) IB_FSH_FLG
      , CASE WHEN MAX(DECODE(CNTR_NO, 'SMCU0000000', NULL, CNTR_NO)) IS NOT NULL THEN NULL -- 반드시 생존해야할 데이터, bkg qty보다 많은것은 상관없음
             WHEN MAX(SO_KNT) > 0 THEN NULL -- 반드시 생존해야할 데이터
             WHEN GREATEST(NVL(MAX(OB_TRO_FLG), 'N'), NVL(MAX(IB_TRO_FLG), 'N')) = 'Y' THEN NULL -- 반드시 생존해야 할 데이터
             WHEN MAX(SCE_CNTR_TPSZ_CD) IS NULL THEN 'C'
             WHEN MAX(BKG_CNTR_TPSZ_CD) IS NULL AND NVL(MAX(SO_KNT),0) = 0 THEN 'X'
             ELSE NULL
        END CALC_COP_OP_TP_CD
         , case
                -- MAX(DECODE(CNTR_NO, 'HJCU0000000', NULL, CNTR_NO)) 을 쓰는 이유는 p3에서 cntr_no가 'HJCU0000000' 가 있으면
                -- 1.group 시 max에서  잘못된 값을 가지고 올수 있어서 null과 cntr_no중 실제 cntr_no를 가져오기 위해 
                -- 2. partition에선 null 이 있으면 제외되므로 nvl 처리 함 
                -- cntr있고 type 매치
                when MAX(BKG_CNTR_TPSZ_CD)=MAX(SCE_CNTR_TPSZ_CD) and nvl(MAX(DECODE(CNTR_NO, 'SMCU0000000', NULL, CNTR_NO)) ,'SMCU0000000')  <>  'SMCU0000000' and 
                        row_number() over (partition by MAX(COP_NO), nvl( MAX(DECODE(CNTR_NO, 'SMCU0000000', NULL, CNTR_NO)) ,'SMCU0000000')  order by 1) =1  then  '1' --'Y'
                -- cntr없고 type 매치
                when MAX(BKG_CNTR_TPSZ_CD)=MAX(SCE_CNTR_TPSZ_CD) and nvl(MAX(DECODE(CNTR_NO, 'SMCU0000000', NULL, CNTR_NO)) ,'SMCU0000000')  =  'SMCU0000000' and 
                        row_number() over (partition by MAX(COP_NO),nvl(MAX(DECODE(CNTR_NO, 'SMCU0000000', NULL, CNTR_NO)) ,'SMCU0000000') order by 1) =1  then '2' --'Y'
                -- cntr 있고 호환type 매치
                when MAX(BKG_CNTR_TPSZ_CD)<>MAX(SCE_CNTR_TPSZ_CD) and nvl(MAX(DECODE(CNTR_NO, 'SMCU0000000', NULL, CNTR_NO)) ,'SMCU0000000')  <> 'SMCU0000000' and 
                        row_number() over (partition by MAX(COP_NO),nvl(MAX(DECODE(CNTR_NO, 'SMCU0000000', NULL, CNTR_NO)) ,'SMCU0000000')  order by  MAX(BKG_CNTR_TPSZ_CD)) =1  then '3' --'Y' 
                -- cntr 없고 호환type 매치
                when MAX(BKG_CNTR_TPSZ_CD)<>MAX(SCE_CNTR_TPSZ_CD) and nvl(MAX(DECODE(CNTR_NO, 'SMCU0000000', NULL, CNTR_NO)) ,'SMCU0000000') = 'SMCU0000000' and 
                        row_number() over (partition by MAX(COP_NO),nvl(MAX(DECODE(CNTR_NO, 'SMCU0000000', NULL, CNTR_NO)) ,'SMCU0000000')  order by 1) =1  then '4' --'Y'  
                --cntr 이 있으면 유지 --nvl 처리 안함 -- 호환된거 없어야 ->MAX(BKG_CNTR_TPSZ_CD) 로 order by하면 호환되는것중 자신은 2가되서 빠져나감
                when  MAX(DECODE(CNTR_NO, 'SMCU0000000', NULL, CNTR_NO))   IS NOT NULL and 
					    MAX(BKG_CNTR_TPSZ_CD) is null and  --jsy
                      row_number() over (partition by MAX(COP_NO), MAX(DECODE(CNTR_NO, 'SMCU0000000', NULL, CNTR_NO))  order by MAX(BKG_CNTR_TPSZ_CD)) =1  
--                        row_number() over (partition by MAX(COP_NO), MAX(DECODE(CNTR_NO, 'HJCU0000000', NULL, CNTR_NO))  order by MAX(BKG_CNTR_TPSZ_CD)) =1 
                    then '0' --'Y'
                --so 있으면 유지 
                when  MAX(SO_KNT) > 0 and
                    row_number() over (partition by MAX(COP_NO), nvl(MAX(DECODE(CNTR_NO, 'SMCU0000000', NULL, CNTR_NO)) ,'SMCU0000000')  order by MAX(BKG_CNTR_TPSZ_CD)) =1
                    then '8'
                --tro 있으면 유지
                WHEN GREATEST(NVL(MAX(OB_TRO_FLG), 'N'), NVL(MAX(IB_TRO_FLG), 'N')) = 'Y' and 
                    row_number() over (partition by MAX(COP_NO), nvl(MAX(DECODE(CNTR_NO, 'SMCU0000000', NULL, CNTR_NO)) ,'SMCU0000000')  order by MAX(BKG_CNTR_TPSZ_CD)) =1
                    then '9'
                --'x'인것 살아남아야   (bkg type 의 qty 가 0 일때 
                when max(decode(OP_CNTR_QTY,999, 0, OP_CNTR_QTY )) =0 and MAX(BKG_CNTR_TPSZ_CD)  is null  AND NVL(MAX(SO_KNT),0) = 0 and -- max(CALC_COP_OP_TP_CD) ='X' and
                         row_number() over (partition by MAX(COP_NO),nvl(MAX(DECODE(CNTR_NO, 'SMCU0000000', NULL, CNTR_NO)) ,'SMCU0000000')  order by 1) =1  then '5' --'Y'    
                --'x'인것 살아남아야   (bkg type 의 qty 가 기존것 보다 작게 들어올때  --D4@1,D5@2,O2@2,O4@2
                when max(decode(OP_CNTR_QTY,999, 0, OP_CNTR_QTY )) > 0 and MAX(BKG_CNTR_TPSZ_CD)  is null  AND NVL(MAX(SO_KNT),0) = 0 and -- max(CALC_COP_OP_TP_CD) ='X' and
                         row_number() over (partition by MAX(COP_NO),nvl(MAX(DECODE(CNTR_NO, 'SMCU0000000', NULL, CNTR_NO)) ,'SMCU0000000')  order by 1) =1  then '6' --'Y' 
                 --신규 생성      
                --when MAX(BKG_CNTR_TPSZ_CD) is not null and MAX(SCE_CNTR_TPSZ_CD) IS NULL and 
                --     row_number() over (partition by MAX(BKG_CNTR_TPSZ_CD),min(OP_CNTR_QTY)   order by nvl(MAX(DECODE(CNTR_NO, 'HJCU0000000', NULL, CNTR_NO)) ,'HJCU0000000') ) <= min(OP_CNTR_QTY)  then '6' --'Y'
                -- 신규로 생성될것 -- 이것은 다시 다음 스텝에서 count 체크하여 정리 
                when MAX(BKG_CNTR_TPSZ_CD) is not null and MAX(SCE_CNTR_TPSZ_CD) IS NULL 
                    then '7' --'S'
                else 'N'
           end used        

     , NVL(MAX(SO_KNT),0) SO_KNT
     -- group 시 max를 가져오므로 실제 값과 비교 
     , max(decode(OP_CNTR_QTY,999, 0, OP_CNTR_QTY )) OP_CNTR_QTY 
     , MAX(BKG_CNTR_TPSZ_CD) BKG_CNTR_TPSZ_CD --JSY
     , MAX(SCE_CNTR_TPSZ_CD) SCE_CNTR_TPSZ_CD -- 나중에 우선이 되어야 함
     ,MAX(BKG_PROV_CNTR_TPSZ_CD)BKG_PROV_CNTR_TPSZ_CD ,MAX(SCE_PROV_CNTR_TPSZ_CD)    SCE_PROV_CNTR_TPSZ_CD 
FROM (
SELECT -- HJCU0000000 중 tpsz가 같은 것끼리 연결된다. (priority 3)
       BKG_NO
     , MAX(BKG_CNTR_TPSZ_CD) BKG_CNTR_TPSZ_CD
     , MAX(SCE_CNTR_TPSZ_CD) SCE_CNTR_TPSZ_CD -- 나중에 우선이 되어야 함
     , NVL(MAX(DECODE(CNTR_NO, 'SMCU0000000', NULL, CNTR_NO)), 'SMCU0000000') CNTR_NO
     , MAX(COP_NO) COP_NO
     , MAX(OB_TRO_FLG) OB_TRO_FLG
     , MAX(IB_TRO_FLG) IB_TRO_FLG
     , MAX(COP_DTL_SEQ) COP_DTL_SEQ
     , MAX(COP_STS_CD) COP_STS_CD
     , MAX(SO_KNT) SO_KNT
     , MAX(GRP_CNTR_TPSZ_CD) GRP_CNTR_TPSZ_CD
     , CASE WHEN MAX(SCE_CNTR_TPSZ_CD) IS NOT NULL AND MAX(BKG_CNTR_TPSZ_CD) IS NOT NULL THEN 'MTCH'|| LPAD(ROW_NUMBER() OVER (ORDER BY 1), 11, '0') --- match(PRIORITY 1,2,3)
            WHEN MAX(SCE_CNTR_TPSZ_CD) IS NULL AND MAX(BKG_PROV_CNTR_TPSZ_CD) IS NULL THEN 'SKIP' || LPAD(ROW_NUMBER() OVER (ORDER BY 1), 11, '0') -- 호환 CONTAINER TPSZ 없음
            ELSE 'WK' || NVL( MAX(SCE_CNTR_TPSZ_CD) , MAX(BKG_PROV_CNTR_TPSZ_CD)) || 'X' -- SCE에 CONTAINER 번호가 있는 CONTAINER TPSZ와 BKG에 있는 호환 CONTAINER TPSZ간 MAPPING
            -- 문제: 호환이 1건이상이고 SCE_CNTR_TPSZ_CD가 null일때 , 호환type이 같은게 있으면 생겨야 할게 중복되어 없어질수 있음.
            -- BKG_CNTR_TPSZ_CD 와 SCE_CNTR_TPSZ_CD 가 group 했을때 있어야 함
                  || LPAD(ROW_NUMBER() OVER (PARTITION BY decode(MAX(SCE_CNTR_TPSZ_CD),null, 'XX',MAX(SCE_PROV_CNTR_TPSZ_CD)|| MAX(SCE_CNTR_TPSZ_CD)  )
                                                           ||NVL(MAX(BKG_CNTR_TPSZ_CD), 'XX') || nvl(MAX(BKG_PROV_CNTR_TPSZ_CD),'XX') 
                          order by GREATEST(NVL(MAX(OB_TRO_FLG), 'N'), NVL(MAX(IB_TRO_FLG), 'N')) desc, 
                                   nvl(max(BKG_CNTR_TPSZ_CD),max(SCE_CNTR_TPSZ_CD)),nvl(max(BKG_PROV_CNTR_TPSZ_CD),max(SCE_PROV_CNTR_TPSZ_CD)), MAX(COP_NO) ), 11, '0')  -- TRO가 있는 것을 우선으로 mapping
       END N4TH_MAP 
     , CASE WHEN MAX(SCE_CNTR_TPSZ_CD) IS NOT NULL AND MAX(BKG_CNTR_TPSZ_CD) IS NOT NULL THEN 'MTCH'  --- match(PRIORITY 1,2,3)
            WHEN MAX(SCE_CNTR_TPSZ_CD) IS NULL AND MAX(BKG_PROV_CNTR_TPSZ_CD) IS NULL THEN 'SKIP'   -- 호환 CONTAINER TPSZ 없음
            ELSE 'WK' || decode( max(BKG_CNTR_TPSZ_CD), null, MAX(SCE_PROV_CNTR_TPSZ_CD)||MAX(SCE_CNTR_TPSZ_CD) ,  MAX(BKG_CNTR_TPSZ_CD)||MAX(BKG_PROV_CNTR_TPSZ_CD)  ) 
            END N4TH_MAP2  
--	 ,ROW_NUMBER() OVER (PARTITION BY CASE WHEN MAX(SCE_CNTR_TPSZ_CD) IS NOT NULL AND MAX(BKG_CNTR_TPSZ_CD) IS NOT NULL THEN 'MTCH'|| MAX(SCE_CNTR_TPSZ_CD)
--                                      WHEN MAX(SCE_CNTR_TPSZ_CD) IS NULL AND MAX(BKG_PROV_CNTR_TPSZ_CD) IS NULL THEN 'SKIP'
--                                      ELSE NVL(MAX(BKG_CNTR_TPSZ_CD) , 'XX') || nvl(MAX(SCE_CNTR_TPSZ_CD), 'XX') END
--                     ORDER BY GREATEST(NVL(MAX(OB_TRO_FLG), 'N'), NVL(MAX(IB_TRO_FLG), 'N')) desc, nvl( max(rns) ,max(rnb) ) ) use_no  --jsy
                   
     , N3rd_MAP  , NVL(max(OP_CNTR_QTY),1) OP_CNTR_QTY , max(rnb) rnb, max(rns) rns
     , MAX(BKG_PROV_CNTR_TPSZ_CD) BKG_PROV_CNTR_TPSZ_CD
     , MAX(SCE_PROV_CNTR_TPSZ_CD) SCE_PROV_CNTR_TPSZ_CD
FROM (
SELECT -- sce Container 번호가 있는 것 mapping 되거나 남음 ( priority 2)
       BKG_NO
     , MAX(BKG_CNTR_TPSZ_CD) BKG_CNTR_TPSZ_CD
     , MAX(SCE_CNTR_TPSZ_CD) SCE_CNTR_TPSZ_CD -- 나중에 우선이 되어야 함
     , MAX(BKG_PROV_CNTR_TPSZ_CD) BKG_PROV_CNTR_TPSZ_CD
     , MAX(SCE_PROV_CNTR_TPSZ_CD) SCE_PROV_CNTR_TPSZ_CD
     , NVL(MAX(DECODE(CNTR_NO, 'SMCU0000000', NULL, CNTR_NO)), 'SMCU0000000') CNTR_NO
     , MAX(COP_NO) COP_NO
     , MAX(OB_TRO_FLG) OB_TRO_FLG
     , MAX(IB_TRO_FLG) IB_TRO_FLG
     , MAX(COP_DTL_SEQ) COP_DTL_SEQ
     , MAX(COP_STS_CD) COP_STS_CD
     , MAX(SO_KNT) SO_KNT
     , CASE WHEN MAX(SCE_CNTR_TPSZ_CD) IS NOT NULL AND MAX(BKG_CNTR_TPSZ_CD) IS NOT NULL THEN 'MTCH' 
--            else NVL(MAX(BKG_CNTR_TPSZ_CD), MAX(SCE_CNTR_TPSZ_CD)) || 'XX' END
            else NVL(MAX(BKG_CNTR_TPSZ_CD), MAX(SCE_CNTR_TPSZ_CD)) || 'XX'|| nvl(max(BKG_PROV_CNTR_TPSZ_CD),max(SCE_PROV_CNTR_TPSZ_CD)) --<-- 추가 jsy type이 중복,  mach 안되는것구분
       END
       || LPAD(ROW_NUMBER() OVER (PARTITION BY CASE WHEN MAX(SCE_CNTR_TPSZ_CD) IS NOT NULL AND MAX(BKG_CNTR_TPSZ_CD) IS NOT NULL THEN 'MTCH'
--                                          ELSE NVL(MAX(BKG_CNTR_TPSZ_CD) , 'XX') || nvl(MAX(SCE_CNTR_TPSZ_CD), 'XX') END
											ELSE NVL(MAX(BKG_CNTR_TPSZ_CD) , 'XX') || nvl(MAX(SCE_CNTR_TPSZ_CD), 'XX') || nvl(max(BKG_PROV_CNTR_TPSZ_CD),max(SCE_PROV_CNTR_TPSZ_CD)) END  --jsy
--                          order by GREATEST(NVL(MAX(OB_TRO_FLG), 'N'), NVL(MAX(IB_TRO_FLG), 'N')) desc, MAX(COP_NO)) -- TRO가 있는 것을 우선으로 mapping
                          order by GREATEST(NVL(MAX(OB_TRO_FLG), 'N'), NVL(MAX(IB_TRO_FLG), 'N')) desc, 
                                   nvl(max(BKG_CNTR_TPSZ_CD),max(SCE_CNTR_TPSZ_CD)),nvl(max(BKG_PROV_CNTR_TPSZ_CD),max(SCE_PROV_CNTR_TPSZ_CD)), MAX(COP_NO) ) -- TRO가 있는 것을 우선으로 mapping

              , 11, '0') N3RD_MAP
     , MAX(GRP_CNTR_TPSZ_CD) GRP_CNTR_TPSZ_CD
     , max(OP_CNTR_QTY) OP_CNTR_QTY --jsy
     , max(rnb) rnb, max(rns) rns, N2ND_MAP
FROM ( SELECT -- container 번호가 있으면서, bkg qty에 tpsz가 있는 것이 매핑 (full mapping priority 1)
        NVL(SCEQ.BKG_NO, QTYQ.BKG_NO) BKG_NO
      , NVL(SCEQ.CNTR_NO, QTYQ.CNTR_NO) CNTR_NO
      , SCEQ.COP_NO
      , SCEQ.OB_TRO_FLG
      , SCEQ.IB_TRO_FLG
      , SCEQ.COP_DTL_SEQ
      , SCEQ.COP_STS_CD
      , SCEQ.CNTR_TPSZ_CD  SCE_CNTR_TPSZ_CD
      , QTYQ.CNTR_TPSZ_CD  BKG_CNTR_TPSZ_CD
      , SCEQ.PROV_CNTR_TPSZ_CD SCE_PROV_CNTR_TPSZ_CD
      , QTYQ.PROV_CNTR_TPSZ_CD BKG_PROV_CNTR_TPSZ_CD
      , NVL( SCEQ.GRP_CNTR_TPSZ_CD, QTYQ.GRP_CNTR_TPSZ_CD ) GRP_CNTR_TPSZ_CD
      , CASE WHEN SCEQ.CNTR_TPSZ_CD IS NOT NULL AND QTYQ.CNTR_TPSZ_CD IS NOT NULL THEN 'MTCH' || LPAD(ROW_NUMBER() OVER (ORDER BY 1), 11, '0') --- match(PRIORITY 1)
             WHEN QTYQ.CNTR_NO IS NULL AND REPLACE(SCEQ.CNTR_NO, 'SMCU0000000') IS NULL THEN 'RMVE' || LPAD(ROW_NUMBER() OVER (ORDER BY 1), 11, '0') -- sce에 container번호가 없음
             WHEN SCEQ.CNTR_TPSZ_CD IS NULL AND QTYQ.PROV_CNTR_TPSZ_CD IS NULL THEN 'SKIP' || LPAD(ROW_NUMBER() OVER (ORDER BY 1), 11, '0') -- 호환 CONTAINER TPSZ 없음
             ELSE nvl(QTYQ.CNTR_TPSZ_CD,SCEQ.PROV_CNTR_TPSZ_CD)||  --<--jsy 추가  (sce에 cntr붙이고 테스트 해봐야..)
				  NVL( SCEQ.CNTR_TPSZ_CD, QTYQ.PROV_CNTR_TPSZ_CD ) || 'X' -- SCE에 CONTAINER 번호가 있는 CONTAINER TPSZ와 BKG에 있는 호환 CONTAINER TPSZ간 MAPPING
   --               || LPAD(ROW_NUMBER() OVER (PARTITION BY NVL(SCEQ.CNTR_TPSZ_CD, 'XX') ||NVL(QTYQ.CNTR_TPSZ_CD, 'XX') ORDER BY SCEQ.COP_NO), 11, '0')
                  || LPAD(ROW_NUMBER() OVER (PARTITION BY --NVL(SCEQ.CNTR_TPSZ_CD, 'XX') 
                                                    decode(SCEQ.CNTR_TPSZ_CD,null, 'XX',SCEQ.PROV_CNTR_TPSZ_CD||SCEQ.CNTR_TPSZ_CD  )
                                                    ||NVL(QTYQ.CNTR_TPSZ_CD, 'XX') ||nvl(QTYQ.PROV_CNTR_TPSZ_CD,'XX')  --호환 type으로 겹치지 않고 같은 type 순으로 seq하려고
                                                 ORDER BY SCEQ.COP_NO  ,nvl(QTYQ.CNTR_TPSZ_CD,SCEQ.PROV_CNTR_TPSZ_CD) ||NVL( SCEQ.CNTR_TPSZ_CD, QTYQ.PROV_CNTR_TPSZ_CD ) ), 11, '0')
         END N2ND_MAP
      , SCEQ.SO_KNT
      ,OP_CNTR_QTY --jsy
	  ,RNS,RNB
   FROM ( -- SCE 측
           SELECT CHDR.BKG_NO
                , NVL(@[flex_hgt_flg], BKGM.FLEX_HGT_FLG) AS FLEX_HGT_FLG
                , NVL(BCNT.CNTR_TPSZ_CD, CHDR.CNTR_TPSZ_CD) CNTR_TPSZ_CD -- CONTAINER 우선
                , NVL(CHDR.CNTR_NO, 'SMCU0000000') CNTR_NO -- 다른 로직을 보면 CNTR_NO가 NULL이 되는 경우가 있는 듯 보여 해당과 같이처리함 (20101012 Park Mangeon)
                , DECODE(NVL(@[flex_hgt_flg], BKGM.FLEX_HGT_FLG), 'Y', GREATEST(CHDR.CNTR_TPSZ_CD,  NVL(RPRL.PROV_CNTR_TPSZ_CD, ' ')),CHDR.CNTR_TPSZ_CD)  GRP_CNTR_TPSZ_CD
                , RPRL.PROV_CNTR_TPSZ_CD
                , CHDR.COP_NO
                , CHDR.OB_TRO_FLG
                , CHDR.IB_TRO_FLG
                , CHDR.COP_STS_CD
                , (SELECT /*+ INDEX_DESC (CDTL XPKSCE_COP_DTL) */ COP_DTL_SEQ
                     FROM SCE_COP_DTL CDTL
                    WHERE CDTL.COP_NO = CHDR.COP_NO
                      AND CDTL.COP_DTL_SEQ >= 4000  -- 적어도 배는 타줘야~
                      AND CDTL.ACT_DT < SYSDATE   --  이미 실행되었음
                      AND ROWNUM = 1) COP_DTL_SEQ
                , SO.SO_KNT
                , NVL(BCNT.CNTR_VOL_QTY, 1) CNTR_VOL_QTY
                , CASE WHEN REPLACE( CHDR.CNTR_NO, 'SMCU0000000', '') IS NULL THEN 100000000 ELSE 0 END
                 + ROW_NUMBER()
                       OVER (PARTITION BY CHDR.CNTR_TPSZ_CD
                              ORDER BY CASE WHEN REPLACE( CHDR.CNTR_NO, 'SMCU0000000', '') IS NOT NULL AND SO.SO_KNT > 0 THEN 1
                                            WHEN REPLACE( CHDR.CNTR_NO, 'SMCU0000000', '') IS NOT NULL THEN 2
                                            WHEN SO.SO_KNT > 0 THEN 3
                                            ELSE 4 END
                                     , CHDR.COP_NO
                       ) SCE_CNTR_ODR
				, row_number() over (partition by NVL(BCNT.CNTR_TPSZ_CD, CHDR.CNTR_TPSZ_CD),CHDR.COP_NO 
                                      order by CASE WHEN REPLACE( CHDR.CNTR_NO, 'SMCU0000000', '') IS NOT NULL AND SO.SO_KNT > 0 THEN 1
                                               WHEN REPLACE( CHDR.CNTR_NO, 'SMCU0000000', '') IS NOT NULL THEN 2
                                               WHEN SO.SO_KNT > 0 THEN 3
                                               ELSE 4 END
                                     , CHDR.COP_NO
								     ,RPRL.PROV_CNTR_TPSZ_CD --jsy
									 ) rns --jsy  
                    , (
                        SELECT --CNTR_TPSZ_CD,
                            replace(MAX(LTRIM(sys_connect_by_path   (PROV_CNTR_TPSZ_CD,'-') ,'-')   ),'-','-')
                        FROM   SCE_COP_CNTR_REPO_RULE SR
                        WHERE  SR.CNTR_TPSZ_CD  =  CHDR.CNTR_TPSZ_CD
                         start with  CNTR_DP_SEQ =1
                        connect by prior CNTR_DP_SEQ= CNTR_DP_SEQ -1 
                         AND prior SR.CNTR_TPSZ_CD  = CHDR.CNTR_TPSZ_CD --'O4'
                      ) PATHS                                     

             FROM BKG_BOOKING BKGM
                , SCE_COP_HDR CHDR
                , SCE_COP_CNTR_REPO_RULE RPRL
                , (
                    SELECT COP_NO,COUNT(1) SO_KNT
                    FROM (
                        SELECT COP_NO,COST_ACT_GRP_SEQ
                        FROM TRS_TRSP_SVC_ORD
                        WHERE BKG_NO = @[bkg_no]
                        AND TRSP_SO_TP_CD <> 'S'
                        AND NVL(RPLN_UMCH_FLG,'N') <> 'Y'
                        AND NVL(TRSP_FRST_FLG,'N') <> 'Y'
                        AND NVL(DELT_FLG,'N') <> 'Y'
                        --BKG에서 REPLAN시 UNMATCH 건은 제외하고 생성하게 처리 20100409
            	    	AND NVL(RPLN_UMCH_FLG,'N') <> 'Y'
                        UNION ALL
                        -- Rail So
                        SELECT
                        A.COP_NO,A.COST_ACT_GRP_SEQ
                        FROM TRS_TRSP_RAIL_BIL_ORD A
                        WHERE A.BKG_NO = @[bkg_no]
            	    	AND NVL(A.TRSP_FRST_FLG,'N') <> 'Y'
                        AND NVL(A.DELT_FLG,'N') <> 'Y'
                        ORDER BY 1,2
                         )
                        GROUP BY COP_NO
                     ) SO
                 , BKG_CONTAINER BCNT
            WHERE BKGM.BKG_NO = @[bkg_no]
              AND CHDR.BKG_NO = BKGM.BKG_NO
              AND NVL(CHDR.COP_STS_CD,'N') <> 'X'
              AND RPRL.CNTR_TPSZ_CD(+) = CHDR.CNTR_TPSZ_CD
              AND SO.COP_NO(+) = CHDR.COP_NO
              AND BCNT.BKG_NO(+) = CHDR.BKG_NO
              AND BCNT.CNTR_NO(+) = CHDR.CNTR_NO
          ) SCEQ
        FULL OUTER JOIN
          ( -- BKG 측
           SELECT BQTY.BKG_NO
                , NVL(@[flex_hgt_flg], BKGM.FLEX_HGT_FLG) as FLEX_HGT_FLG
                , BQTY.CNTR_TPSZ_CD
                , 'SMCU0000000' AS CNTR_NO
                , DECODE(NVL(@[flex_hgt_flg], BKGM.FLEX_HGT_FLG), 'Y', GREATEST(BQTY.CNTR_TPSZ_CD,  NVL(RPRL.PROV_CNTR_TPSZ_CD, ' ')), BQTY.CNTR_TPSZ_CD) GRP_CNTR_TPSZ_CD
                , RPRL.PROV_CNTR_TPSZ_CD
                , ROW_NUMBER()OVER(PARTITION BY BQTY.CNTR_TPSZ_CD ORDER BY CPY_NO) AS QTY_CNTR_ODR
				, OP_CNTR_QTY --jsy
				, CPNO.CPY_NO
				, row_number() over (partition by BQTY.CNTR_TPSZ_CD,CPY_NO order by CPY_NO) rnb
                , (
                    SELECT --CNTR_TPSZ_CD,
                        replace(MAX(LTRIM(sys_connect_by_path   (PROV_CNTR_TPSZ_CD,'-') ,'-')   ),'-','-')
                    FROM   SCE_COP_CNTR_REPO_RULE SR
                    WHERE  SR.CNTR_TPSZ_CD  =  BQTY.CNTR_TPSZ_CD
                     start with  CNTR_DP_SEQ =1
                     connect by prior CNTR_DP_SEQ= CNTR_DP_SEQ -1 
                     AND prior SR.CNTR_TPSZ_CD  = BQTY.CNTR_TPSZ_CD --'O4'
                  ) PATHB					

             FROM BKG_BOOKING BKGM
               , (SELECT @[bkg_no] AS BKG_NO
                       , BKG_GET_TOKEN_FNC(COLUMN_VALUE, 1, '@') CNTR_TPSZ_CD
                       , TO_NUMBER(BKG_GET_TOKEN_FNC(COLUMN_VALUE, 2, '@')) OP_CNTR_QTY
                    FROM TABLE(SELECT BKG_SPLIT_FNC(@[cntr_tpsz_qty], ',') CNTR_TPSZ_QTY_TBL_STR FROM DUAL )
                  ) BQTY
               , COM_CPY_NO CPNO
               , SCE_COP_CNTR_REPO_RULE RPRL
           WHERE BKGM.BKG_NO = @[bkg_no]
             AND BQTY.BKG_NO = BKGM.BKG_NO
             AND RPRL.CNTR_TPSZ_CD(+) = BQTY.CNTR_TPSZ_CD
             AND CPNO.CPY_NO < BQTY.OP_CNTR_QTY
         ) QTYQ
       ON (   SCEQ.CNTR_TPSZ_CD = QTYQ.CNTR_TPSZ_CD
          AND SCEQ.SCE_CNTR_ODR = QTYQ.QTY_CNTR_ODR
          )
    )
GROUP BY BKG_NO, N2ND_MAP
)
GROUP BY BKG_NO, N3RD_MAP
)
--where use_no <= OP_CNTR_QTY --jsy
GROUP BY BKG_NO, N4TH_MAP,N4TH_MAP2
    )
    where used <>'N'
) -- END OF FH_QTY
, SO_INFO AS (
    SELECT ROWNUM,H.COP_NO,H.CNTR_NO,H.CNTR_TPSZ_CD, SO_KNT,
          OB_TRO_FLG,IB_TRO_FLG,BC.POR_NOD_CD,BC.POL_YD_CD POL_NOD_CD, BKG.POR_NOD_CD POR_ZN_CD,BKG.DEL_NOD_CD,
        -- MIXED TERM 일때 BKG_CONTAINER 의 TERM 을 사용
        -- NVL(RCV_TERM_CD,:rcv_t) RCV_TERM_CD,NVL(DE_TERM_CD,:del_t) DE_TERM_CD,
		  DECODE(@[bkg_rcv_t], 'M',  NVL(BC.RCV_TERM_CD,@[rcv_t]), @[rcv_t]) RCV_TERM_CD,
		  DECODE(@[bkg_del_t], 'M',  NVL(BC.DE_TERM_CD,@[del_t]), @[del_t]) DE_TERM_CD,
        --:rcv_t RCV_TERM_CD,:del_t DE_TERM_CD,
        (SELECT DECODE(LENGTH(TO_NOD_CD), 7, TO_NOD_CD) FROM TRS_TRSP_SVC_ORD T -- S/O가 항상 YARD단위로 나는 것이 아니기 때문에, 7자리가 아닌 경우 무시한다. 2012.03.13 MGPARK
            WHERE T.COP_NO = H.COP_NO
            AND T.TRSP_BND_CD ='O'
            AND T.TRSP_SO_TP_CD <> 'S'
            AND T.DOR_NOD_CD IS NOT NULL 
            AND NVL(T.RPLN_UMCH_FLG,'N') <> 'Y'
            AND NVL(T.TRSP_FRST_FLG,'N') <> 'Y'
            AND NVL(T.DELT_FLG,'N') <> 'Y')
         MT_PU, -- MTY PU/RTN은 영향을 Pattern에 영향을 미치지 않도록 2010년 5월 처리되었으나, S/O가 있는 경우에만 예외 처리한다.(DOOR S/O만) 2012.03.12 MGPARK
        (SELECT DECODE(LENGTH(TO_NOD_CD), 7, TO_NOD_CD) FROM TRS_TRSP_SVC_ORD T
            WHERE T.COP_NO = H.COP_NO
            AND T.TRSP_BND_CD ='I'
            AND T.TRSP_SO_TP_CD <> 'S'
            AND T.DOR_NOD_CD IS NOT NULL 
            AND NVL(T.RPLN_UMCH_FLG,'N') <> 'Y'
            AND NVL(T.TRSP_FRST_FLG,'N') <> 'Y'
            AND NVL(T.DELT_FLG,'N') <> 'Y')
         MT_RTN,
--          COUNT(H.COP_NO) OVER ( PARTITION BY PU.NOD_CD ) PU_CNT,
--          COUNT(H.COP_NO) OVER ( PARTITION BY RTN.NOD_CD ) RTN_CNT,
          H.OB_FSH_FLG,H.IB_FSH_FLG, H.CALC_COP_OP_TP_CD
    FROM FH_QTY H
--        , SCE_COP_DTL PU
--        , SCE_COP_DTL RTN
        , BKG_CONTAINER BC
        , BKG_BOOKING BKG
    WHERE H.BKG_NO = @[bkg_no]
    AND H.BKG_NO = BKG.BKG_NO
    AND H.CNTR_NO = BC.CNTR_NO(+)
    AND H.BKG_NO = BC.BKG_NO(+)
    and h.USED2='Y'  --jsy
--      AND NVL(H.COP_STS_CD,'N') <> 'X'
--    AND H.COP_NO = PU.COP_NO(+)
--    AND PU.ACT_CD(+) = 'MOTYDO'
--    AND PU.ACT_DT(+) IS NOT NULL
--    AND H.COP_NO = RTN.COP_NO(+)
--    AND RTN.ACT_CD(+) = 'MITYAD'
--    AND RTN.ACT_DT(+) IS NOT NULL
)  -- END OF SO_INFO
, ROUT_OUTPUT AS (
    SELECT B.COP_NO,B.CNTR_NO,B.CNTR_TPSZ_CD, SO_KNT,NVL(OB_TRO_FLG,'N') OB_TRO_FLG, NVL(IB_TRO_FLG,'N') IB_TRO_FLG,
        POR_NOD_CD,POL_NOD_CD,RCV_TERM_CD,DE_TERM_CD, MT_PU, MT_RTN,
        --NVL(MT_PU,FIRST_VALUE(MT_PU) OVER  (ORDER BY PU_CNT DESC ROWS UNBOUNDED PRECEDING)) MT_PU,	=> DEL #2010.06.03 by sj
        --NVL(MT_RTN,FIRST_VALUE(MT_RTN) OVER  (ORDER BY RTN_CNT DESC ROWS UNBOUNDED PRECEDING)) MT_RTN,=> DEL #2010.06.03 by sj
        (CASE WHEN (SELECT CONTI_CD FROM MDM_LOCATION L WHERE L.LOC_CD = SUBSTR(B.POR_ZN_CD,1,5) AND NVL(L.DELT_FLG,'N')='N') ='E'
               AND NVL((SELECT DOR_NOD_CD FROM TRS_TRSP_SVC_ORD
                         WHERE COP_NO =B.COP_NO
                           AND TRSP_BND_CD = 'O'
                           AND TRSP_SO_TP_CD <> 'S'
                           AND NVL(RPLN_UMCH_FLG,'N') <> 'Y'
                           AND NVL(TRSP_FRST_FLG,'N') <> 'Y'
                           AND NVL(DELT_FLG,'N') <> 'Y'
                           AND DOR_NOD_CD IS NOT NULL),B.POR_ZN_CD) <> B.POR_ZN_CD
              THEN PRD_GET_COP_NO_EUR_DR_STR_FNC (B.COP_NO,'O')
              ELSE PRD_GET_COP_BND_SO_STR_FNC (B.COP_NO,'O')
        END) OUT_BOUND,
        (CASE WHEN (SELECT CONTI_CD FROM MDM_LOCATION L WHERE L.LOC_CD = SUBSTR(B.DEL_NOD_CD,1,5) AND NVL(L.DELT_FLG,'N')='N') ='E'
               AND NVL((SELECT DOR_NOD_CD FROM TRS_TRSP_SVC_ORD
                         WHERE COP_NO =B.COP_NO
                           AND TRSP_BND_CD = 'I'
                           AND TRSP_SO_TP_CD <> 'S'
                           AND NVL(RPLN_UMCH_FLG,'N') <> 'Y'
                           AND NVL(TRSP_FRST_FLG,'N') <> 'Y'
                           AND NVL(DELT_FLG,'N') <> 'Y'
                           AND DOR_NOD_CD IS NOT NULL ),B.DEL_NOD_CD) <> B.DEL_NOD_CD
              THEN PRD_GET_COP_NO_EUR_DR_STR_FNC (B.COP_NO,'I')
              ELSE PRD_GET_COP_BND_SO_STR_FNC (B.COP_NO,'I')
        END)  IN_BOUND,
        PRD_GET_COP_BND_SO_STR_FNC (B.COP_NO,'T') OCN,
        B.OB_FSH_FLG,B.IB_FSH_FLG, B.CALC_COP_OP_TP_CD
        ,POR_ZN_CD --JSY
    FROM SO_INFO B
) -- END OF ROUT_OUTPUT
select 
     BKG_NO,PCTL_NO,COP_NO,COP_MAPG_SEQ,CRNT_FLG,COP_OP_TP_CD,CNTR_NO,BKG_OP_RMK,CNTR_TPSZ_CD,COP_SO_KNT,MTY_RTN_YD_CD,OB_TRO_FLG,IB_TRO_FLG,POR_NOD_CD,POL_NOD_CD
    ,BKG_RCV_TERM_CD,BKG_DE_TERM_CD,OB_ITCHG_CTNT,IB_ITCHG_CTNT,OCN_ITCHG_CTNT,COP_PATT_ORD_NO,OB_FSH_FLG,IB_FSH_FLG,DUP_RN
    from (
    select 
        BKG_NO,PCTL_NO,COP_NO,COP_MAPG_SEQ,CRNT_FLG,COP_OP_TP_CD,CNTR_NO,BKG_OP_RMK,CNTR_TPSZ_CD,COP_SO_KNT,MTY_RTN_YD_CD,OB_TRO_FLG,IB_TRO_FLG,POR_NOD_CD,POL_NOD_CD
        ,BKG_RCV_TERM_CD,BKG_DE_TERM_CD,OB_ITCHG_CTNT,IB_ITCHG_CTNT,OCN_ITCHG_CTNT,COP_PATT_ORD_NO,OB_FSH_FLG,IB_FSH_FLG
        ,row_number() over(partition by BKG_NO,PCTL_NO,COP_NO,COP_MAPG_SEQ order by COP_NO ) dup_rn
    from 
    (
SELECT NVL(H2.BKG_NO, @[bkg_no]) AS BKG_NO
     , CASE WHEN CALC_COP_OP_TP_CD = 'C' THEN (SELECT B.PCTL_NO FROM BKG_BOOKING B WHERE B.BKG_NO = @[bkg_no] ) -- 신규는 booking의 pc 번호 사용
            WHEN (P.OB_TRO_FLG = 'Y' OR P.IB_TRO_FLG = 'Y') AND NVL(P.CNTR_NO, 'SMCU0000000') = 'SMCU0000000' THEN (SELECT B.PCTL_NO FROM BKG_BOOKING B WHERE B.BKG_NO = @[bkg_no] ) -- 신규는 booking의 pc 번호 사용
            ELSE NVL(H2.PCTL_NO, MAX(H2.PCTL_NO) OVER ())
       END AS PCTL_NO
     , CASE WHEN P.COP_NO IS NOT NULL THEN P.COP_NO
            ELSE SCE_NEW_COP_NO_FNC(@[bkg_ofc]) END AS COP_NO
     , @[mapg_seq] COP_MAPG_SEQ
     , 'Y' CRNT_FLG
     , NVL(CALC_COP_OP_TP_CD, @[current_flag]) COP_OP_TP_CD
     , P.CNTR_NO
     , 'REPLAN' BKG_OP_RMK
     , P.CNTR_TPSZ_CD
     , SO_KNT  COP_SO_KNT
--     , MT_PU   MTY_PKUP_YD_CD
--     , MT_RTN  MTY_RTN_YD_CD
     , DECODE(1, (SELECT 1 FROM MDM_YARD WHERE YD_CD = MT_RTN AND NVL(DELT_FLG,'N') = 'N'), NULL, (SELECT 1 FROM MDM_LSE_CO_YD WHERE LSE_CO_YD_CD = MT_RTN), MT_RTN, NULL) MTY_RTN_YD_CD
     , P.OB_TRO_FLG
     , P.IB_TRO_FLG
     , P.POR_NOD_CD
     , P.POL_NOD_CD
     , RCV_TERM_CD BKG_RCV_TERM_CD
     , DE_TERM_CD BKG_DE_TERM_CD
     , OUT_BOUND OB_ITCHG_CTNT
     , IN_BOUND IB_ITCHG_CTNT
     , OCN OCN_ITCHG_CTNT
	 , DENSE_RANK() OVER ( ORDER BY ORG_J, TPSZ_ORD, FULL_CNTS DESC, FULL_ROUT ) COP_PATT_ORD_NO --JSY
     , DENSE_RANK() OVER ( ORDER BY FULL_CNTS DESC, FULL_ROUT ) COP_PATT_ORD_NO_OLD
     , OB_FSH_FLG
     , IB_FSH_FLG
 FROM (SELECT ROUT.COP_NO,ROUT.CNTR_NO,ROUT.CNTR_TPSZ_CD,ROUT.SO_KNT,ROUT.OUT_BOUND,ROUT.IN_BOUND,ROUT.OCN
          , MT_PU,MT_RTN
	      , OB_TRO_FLG,IB_TRO_FLG,POR_NOD_CD,POL_NOD_CD,RCV_TERM_CD,DE_TERM_CD
          , COUNT(1) OVER (PARTITION BY OB_TRO_FLG||IB_TRO_FLG||NVL(POR_NOD_CD,'AAAAAAA')||NVL(POL_NOD_CD, 'AAAAAAA')||RCV_TERM_CD||DE_TERM_CD||ROUT.OUT_BOUND||ROUT.OCN||ROUT.IN_BOUND||NVL(MT_PU,'AAAAAAA')||NVL(MT_RTN,'AAAAAAA')) FULL_CNTS
          , OB_TRO_FLG||IB_TRO_FLG||NVL(POR_NOD_CD,'AAAAAAA')||NVL(POL_NOD_CD, 'AAAAAAA')||RCV_TERM_CD||DE_TERM_CD||ROUT.OUT_BOUND||ROUT.OCN||ROUT.IN_BOUND||NVL(MT_PU,'AAAAAAA')||NVL(MT_RTN,'AAAAAAA') FULL_ROUT
          , ROUT.OB_FSH_FLG,ROUT.IB_FSH_FLG, CALC_COP_OP_TP_CD
          ,DECODE(POR_ZN_CD,  POR_NOD_CD, 0,1) ORG_J  --JSY
		  ,DECODE(SUBSTR(ROUT.CNTR_TPSZ_CD,0,1), 'Q', 1, 0) TPSZ_ORD  --Q TYPE 은 VOID로 실제 컨테이너가 없다. 순위에서 뒤로 밀림
          ,POR_ZN_CD
       FROM ROUT_OUTPUT ROUT
      ) P
    , SCE_COP_HDR H2
 WHERE P.COP_NO = H2.COP_NO(+)
    ) 
) 
where dup_rn = 1			]]></sql>
			<params>
				<param name="flex_hgt_flg" type="12" value="" out="N"/>
				<param name="bkg_no" type="12" value="" out="N"/>
				<param name="cntr_tpsz_qty" type="12" value="" out="N"/>
				<param name="bkg_rcv_t" type="12" value="" out="N"/>
				<param name="rcv_t" type="12" value="" out="N"/>
				<param name="bkg_del_t" type="12" value="" out="N"/>
				<param name="del_t" type="12" value="" out="N"/>
				<param name="bkg_ofc" type="12" value="" out="N"/>
				<param name="mapg_seq" type="12" value="" out="N"/>
				<param name="current_flag" type="12" value="" out="N"/>
			</params>
		</query>
	</querys>
</sqls>
